---
interface Props {
  pdfUrl: string;
}
const { pdfUrl } = Astro.props;
---

<div class="viewer-shell" id="viewer-shell" data-pdf-url={pdfUrl}>
  <!-- Toolbar -->
  <div class="toolbar" id="toolbar">
    <div class="toolbar-left">
      <span class="prompt">resume.pdf</span>
      <span class="toolbar-sep">|</span>
      <button class="btn" id="btn-prev" title="Previous page (←)">&#9664;</button>
      <span class="page-indicator">
        <span id="page-num">1</span>
        <span class="page-sep">/</span>
        <span id="page-count">—</span>
      </span>
      <button class="btn" id="btn-next" title="Next page (→)">&#9654;</button>
    </div>
    <div class="toolbar-right">
      <button class="btn" id="btn-zoom-out" title="Zoom out (-)">&#8722;</button>
      <span class="zoom-display"><span id="zoom-pct">100</span>%</span>
      <button class="btn" id="btn-zoom-in" title="Zoom in (+)">&#43;</button>
      <button class="btn btn-fit" id="btn-fit" title="Fit to width">FIT</button>
      <button class="btn btn-dl" id="btn-download" title="Download PDF">DL</button>
    </div>
  </div>

  <!-- Loading state -->
  <div class="loader" id="loader">
    <span class="loader-text" id="loader-text">loading document...</span>
    <div class="loader-bar"><div class="loader-fill" id="loader-fill"></div></div>
  </div>

  <!-- Empty state -->
  <div class="empty-state" id="empty-state" style="display:none">
    <pre class="ascii-box">
╔══════════════════════════════╗
║   no resume found            ║
║                              ║
║   push a .tex file to        ║
║   latex/ to compile one      ║
╚══════════════════════════════╝</pre>
  </div>

  <!-- Canvas viewport -->
  <div class="canvas-viewport" id="canvas-viewport">
    <div class="page-container" id="page-container">
      <canvas id="pdf-canvas"></canvas>
    </div>
  </div>

  <!-- Scanline overlay -->
  <div class="scanlines" aria-hidden="true"></div>
</div>

<style>
  .viewer-shell {
    position: relative;
    display: flex;
    flex-direction: column;
    height: 100%;
    background: #000;
    border: 1px solid var(--dim, #3a4a3a);
    overflow: hidden;
    font-family: 'JetBrains Mono', 'Courier New', Courier, monospace;
  }

  /* ── Toolbar ── */
  .toolbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 5px 12px;
    border-bottom: 1px solid var(--dim, #3a4a3a);
    background: #000;
    flex-shrink: 0;
    gap: 8px;
    flex-wrap: wrap;
    z-index: 10;
  }

  .toolbar-left,
  .toolbar-right {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .prompt {
    color: var(--info, #61afef);
    font-size: 0.78rem;
    letter-spacing: 0.04em;
    opacity: 0.85;
  }

  .toolbar-sep {
    color: var(--dim, #3a4a3a);
    user-select: none;
  }

  .btn {
    background: transparent;
    border: 1px solid var(--dim, #3a4a3a);
    color: var(--primary, #98c379);
    font-family: inherit;
    font-size: 0.72rem;
    padding: 2px 7px;
    cursor: pointer;
    transition: background 0.12s, color 0.12s, border-color 0.12s;
    letter-spacing: 0.04em;
    min-width: 24px;
  }

  .btn:hover {
    background: var(--primary, #98c379);
    color: #000;
    border-color: var(--primary, #98c379);
  }

  .btn:disabled {
    opacity: 0.25;
    cursor: default;
  }

  .btn:disabled:hover {
    background: transparent;
    color: var(--primary, #98c379);
    border-color: var(--dim, #3a4a3a);
  }

  .btn-fit { font-size: 0.62rem; letter-spacing: 0.08em; }

  .btn-dl {
    font-size: 0.62rem;
    letter-spacing: 0.08em;
    border-color: var(--info, #61afef);
    color: var(--info, #61afef);
  }

  .btn-dl:hover {
    background: var(--info, #61afef);
    color: #000;
  }

  .page-indicator {
    display: flex;
    align-items: center;
    gap: 4px;
    color: var(--primary, #98c379);
    font-size: 0.78rem;
    min-width: 58px;
    justify-content: center;
  }

  .page-sep { color: var(--dim, #3a4a3a); }

  .zoom-display {
    color: var(--primary, #98c379);
    font-size: 0.78rem;
    min-width: 40px;
    text-align: center;
  }

  /* ── Loader ── */
  .loader {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    flex: 1;
    gap: 16px;
    padding: 40px;
  }

  .loader-text {
    color: var(--primary, #98c379);
    font-size: 0.82rem;
    letter-spacing: 0.1em;
    animation: blink 1s step-end infinite;
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  .loader-bar {
    width: 200px;
    height: 2px;
    background: #1a1a1a;
    border: 1px solid var(--dim, #3a4a3a);
  }

  .loader-fill {
    height: 100%;
    background: var(--primary, #98c379);
    width: 0%;
    transition: width 0.3s ease;
  }

  /* ── Empty state ── */
  .empty-state {
    display: flex;
    align-items: center;
    justify-content: center;
    flex: 1;
    padding: 40px;
  }

  .ascii-box {
    color: var(--primary, #98c379);
    font-size: 0.78rem;
    line-height: 1.5;
    margin: 0;
    opacity: 0.5;
  }

  /* ── Canvas viewport ── */
  .canvas-viewport {
    flex: 1;
    overflow: auto;
    display: none;
    align-items: center;
    justify-content: center;
    padding: 20px 14px;
    background: #0a0a0a;
  }

  .page-container {
    position: relative;
    display: inline-block;
    box-shadow: 0 4px 24px rgba(0,0,0,0.6);
  }

  #pdf-canvas {
    display: block;
    background: #fff;
  }

  /* ── Scanlines ── */
  .scanlines {
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      to bottom,
      transparent 0px,
      transparent 3px,
      rgba(0, 0, 0, 0.04) 3px,
      rgba(0, 0, 0, 0.04) 4px
    );
    pointer-events: none;
    z-index: 5;
  }
</style>

<script>
  import { GlobalWorkerOptions, getDocument } from 'pdfjs-dist';

  GlobalWorkerOptions.workerSrc = '/pdf.worker.min.mjs';

  (async () => {
    const shell       = document.getElementById('viewer-shell');
    const loaderEl    = document.getElementById('loader');
    const loaderFill  = document.getElementById('loader-fill');
    const loaderText  = document.getElementById('loader-text');
    const emptyEl     = document.getElementById('empty-state');
    const viewport    = document.getElementById('canvas-viewport');
    const canvas      = document.getElementById('pdf-canvas');
    const pageNumEl   = document.getElementById('page-num');
    const pageCountEl = document.getElementById('page-count');
    const zoomPctEl   = document.getElementById('zoom-pct');
    const btnPrev     = document.getElementById('btn-prev');
    const btnNext     = document.getElementById('btn-next');
    const btnZoomOut  = document.getElementById('btn-zoom-out');
    const btnZoomIn   = document.getElementById('btn-zoom-in');
    const btnFit      = document.getElementById('btn-fit');
    const btnDl       = document.getElementById('btn-download');

    let pdfDoc       = null;
    let currentPage  = 1;
    let currentScale = 1.5;
    let currentUrl   = shell.dataset.pdfUrl ?? '';
    let rendering    = false;
    let initializing = false;  // guard against ResizeObserver firing during load

    // ── Render a page at high DPI ──
    async function renderPage(pageNum) {
      if (!pdfDoc || rendering) return;
      rendering = true;

      const page     = await pdfDoc.getPage(pageNum);
      const dpr      = window.devicePixelRatio || 1;
      const vp       = page.getViewport({ scale: currentScale });
      const ctx      = canvas.getContext('2d');

      // Render at native device resolution, display at logical size
      canvas.width  = Math.floor(vp.width  * dpr);
      canvas.height = Math.floor(vp.height * dpr);
      canvas.style.width  = Math.floor(vp.width)  + 'px';
      canvas.style.height = Math.floor(vp.height) + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      await page.render({ canvasContext: ctx, viewport: vp }).promise;

      pageNumEl.textContent = pageNum;
      btnPrev.disabled = pageNum <= 1;
      btnNext.disabled = pageNum >= pdfDoc.numPages;
      rendering = false;
    }

    // ── Load a PDF by URL ──
    async function loadPdf(url) {
      if (!url) {
        loaderEl.style.display  = 'none';
        emptyEl.style.display   = 'flex';
        viewport.style.display  = 'none';
        return;
      }

      currentUrl   = url;
      currentPage  = 1;
      loaderEl.style.display  = 'flex';
      emptyEl.style.display   = 'none';
      viewport.style.display  = 'none';
      loaderFill.style.width  = '10%';
      loaderText.textContent  = 'loading document...';

      const loadingTask = getDocument(url);

      loadingTask.onProgress = (prog) => {
        if (prog.total > 0) {
          loaderFill.style.width = Math.round((prog.loaded / prog.total) * 90) + '%';
        }
      };

      try {
        pdfDoc = await loadingTask.promise;
        loaderFill.style.width = '100%';

        pageCountEl.textContent = pdfDoc.numPages;

        // Show viewport BEFORE fitToWidth so clientWidth is non-zero.
        // Guard initializing so the ResizeObserver doesn't trigger a second render.
        initializing = true;
        loaderEl.style.display  = 'none';
        viewport.style.display  = 'flex';

        await fitToPage(false);
        await renderPage(1);
        initializing = false;
      } catch (err) {
        loaderText.textContent = 'error loading pdf: ' + err.message;
        loaderFill.style.width = '0%';
        console.error(err);
      }
    }

    // ── Fit entire page on screen ──
    async function fitToPage(andRender = true) {
      if (!pdfDoc) return;
      const page       = await pdfDoc.getPage(currentPage);
      const vp         = page.getViewport({ scale: 1 });
      const container  = document.getElementById('canvas-viewport');
      const padW = 48, padH = 48;
      const scaleW = (container.clientWidth  - padW) / vp.width;
      const scaleH = (container.clientHeight - padH) / vp.height;
      currentScale = Math.min(scaleW, scaleH);
      if (currentScale <= 0) currentScale = 1;
      zoomPctEl.textContent = Math.round(currentScale * 100);
      if (andRender) await renderPage(currentPage);
    }

    // ── Controls ──
    btnPrev.addEventListener('click', async () => {
      if (currentPage > 1) { currentPage--; await renderPage(currentPage); }
    });

    btnNext.addEventListener('click', async () => {
      if (pdfDoc && currentPage < pdfDoc.numPages) { currentPage++; await renderPage(currentPage); }
    });

    btnZoomOut.addEventListener('click', async () => {
      currentScale = Math.max(0.25, currentScale - 0.25);
      zoomPctEl.textContent = Math.round(currentScale * 100);
      await renderPage(currentPage);
    });

    btnZoomIn.addEventListener('click', async () => {
      currentScale = Math.min(4, currentScale + 0.25);
      zoomPctEl.textContent = Math.round(currentScale * 100);
      await renderPage(currentPage);
    });

    btnFit.addEventListener('click', () => fitToPage());

    btnDl.addEventListener('click', () => {
      const a = document.createElement('a');
      a.href     = currentUrl;
      a.download = currentUrl.split('/').pop();
      a.click();
    });

    // ── Keyboard navigation ──
    document.addEventListener('keydown', async (e) => {
      if (!pdfDoc) return;
      if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === 'PageDown') {
        if (currentPage < pdfDoc.numPages) { currentPage++; await renderPage(currentPage); }
      } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp' || e.key === 'PageUp') {
        if (currentPage > 1) { currentPage--; await renderPage(currentPage); }
      } else if (e.key === '+' || e.key === '=') {
        currentScale = Math.min(4, currentScale + 0.25);
        zoomPctEl.textContent = Math.round(currentScale * 100);
        await renderPage(currentPage);
      } else if (e.key === '-') {
        currentScale = Math.max(0.25, currentScale - 0.25);
        zoomPctEl.textContent = Math.round(currentScale * 100);
        await renderPage(currentPage);
      }
    });

    // ── Listen for version-switch events from VersionList ──
    window.addEventListener('load-version', async (e) => {
      await loadPdf(e.detail.url);
    });

    // ── Resize: re-fit (skip during initial load to avoid double-render) ──
    const ro = new ResizeObserver(() => { if (pdfDoc && !initializing) fitToPage(); });
    ro.observe(document.getElementById('canvas-viewport'));

    // ── Initial load ──
    await loadPdf(currentUrl);
  })();
</script>
